Object.display = function(object) { var s = ""; if (typeof object === "object" && object !== null) { s += object.constructor.name + " {\n"; for (let x in object) { s += `${x}: ${object[x]}\n`; } s += "}"; } else { s += object; } console.log(s); }; class Random { #value = Random.value; constructor() { return null; } static get value() { return Math.random(); } static int(a,b = 0) { const minimum = Math.min(a,b); const range = Math.abs(a-b)+1; return minimum + Math.floor(range * Random.value); } static pick(...elements) { var choices = elements; if (elements.length < 2) choices = elements[0]; if (!Array.isArray(choices)) choices = [choices]; return choices[Random.int(choices.length - 1)]; } get value() { return this.#value; } } class XMLElement { #main; #namespace; constructor(XMLObject = document.documentElement, setters = null) { this.#main = XMLObject; this.#namespace = this.#main.namespaceURI || null; if(setters) { if(!Array.isArray(setters)) setters = Object.entries(setters); setters.storage = {}; setters.forEach(property => { var key, value; if(Array.isArray(property)) [key, value] = property; else { key = property; value = null; } if(key.slice(-1) == "*") { key = key.slice(0, -1); setters.storage[key] = { value: this.#main[key], enumerable: true, configurable: true, writable: true, } } else { setters.storage[key] = { set(value) { this.#main.setAttributeNS(null, key, value); }, get() { return this.#main.getAttributeNS(null, key); }, enumerable: true, configurable: true, } } Object.defineProperties(this, setters.storage); if(value !== null && !Number.isNaN(value)) this[key] = value; }); } } get XMLObject() { return this.#main; } get XMLString() { return new XMLSerializer().serializeToString(this.#main); } append(child, next = null, setters = null, namespace = this.#namespace || null) { if (child.constructor.name == "String") child = document.createElementNS(namespace, child); if(child != null && child.constructor == this.constructor) child = child.XMLObject; if (next != null && next.constructor == this.constructor) next = next.XMLObject; return new this.constructor(this.#main.insertBefore(child, next), setters); } prepend(child, setters = null, namespace = this.#namespace || null) { if (child.constructor.name == "String") child = document.createElementNS(namespace, child); if(child != null && child.constructor == this.constructor) child = child.XMLObject; return new this.constructor(this.#main.prepend(child), setters); } appendGroup(iterable, next = null, setters = null, namespace = this.#namespace || null) { var output = []; for (let child of iterable) { output.push(this.append(child)); }; return output; } write(text) { this.#main.append(document.createTextNode(text)); return this; } clear() { this.#main.textContent = ""; return this; } remove() { this.#main.remove(); } on(event, action, ...options) { let obj = {}; options.map(o=>obj[o]=true); this.#main.addEventListener(event, action, obj); return this; } } class XMLDocument { #document; #script; constructor(script = function (root) { return; }, root = "root", namespace = "", doctype = "xml", dtdPUBLIC = "", dtdSYSTEM = "") { this.#document = document.implementation.createDocument(namespace, root, document.implementation.createDocumentType(doctype, dtdPUBLIC, dtdSYSTEM)); this.#script = script; this.#script(new XMLElement(this.#document.documentElement)); } get XMLObject() { return this.#document; } get XMLString() { return new XMLSerializer().serializeToString(this.#document); } load() { this.#script(new XMLElement(document.documentElement).clear()); } } class HTMLElement extends XMLElement { #main; #namespace = "http://www.w3.org/1999/xhtml"; constructor(HTMLObject, setters = null) { super(HTMLObject, setters); this.#main = HTMLObject; Object.defineProperty(this, "appendNS", { value: super.append, enumerable: false, }); Object.defineProperty(this, "prependNS", { value: super.prepend, enumerable: false, }); } get HTMLObject() { return super.XMLObject; } get HTMLString() { return super.XMLString; } append(child, next = null, setters = null) { return this.appendNS(child, next, setters, this.#namespace); } prepend(child, next = null, setters = null) { return this.prependNS(child, next, setters, this.#namespace); } appendGroup(iterable, next = null, setters = null) { return super.appendGroup(iterable, next, setters); } } class HTMLDocument extends XMLDocument { #document; #title; #script; constructor(script = function (body, head) { return; }, title = document.title) { super(); this.#document = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", document.implementation.createDocumentType("html", "", "")); this.#document.documentElement.innerHTML = "<head></head><body></body>"; this.#title = title; this.#script = script; this.#script(new HTMLElement(this.#document.body), new HTMLElement(this.#document.querySelector("head"))); } get HTMLObject() { return super.XMLObject; } get HTMLString() { return super.XMLString; } load(keepHead = true) { if (!keepHead) { new HTMLElement(document.querySelector("head")).clear(); } document.title = this.#title; this.#script(new HTMLElement(document.body).clear(), new HTMLElement(document.querySelector("head"))); } } class SVGElement extends XMLElement { #main; #namespace = "http://www.w3.org/2000/svg"; constructor(SVGObject, setters = null) { super(SVGObject, setters); this.#main = SVGObject; Object.defineProperty(this, "appendNS", { value: super.append, enumerable: false, }); } get SVGObject() { return super.XMLObject; } append(tag, next = null, setters = null) { return this.appendNS(tag, next, setters, this.#namespace); } use(id, next = null) { return super.append("use", next, [["href", "#" + id], "x", "y", "width", "height"], this.#namespace); } }
